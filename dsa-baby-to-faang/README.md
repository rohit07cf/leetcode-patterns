# DSA Baby to FAANG

## Your Friendly Guide to Data Structures, Algorithms, and Landing That Dream Job

---

## Welcome, Friend

Hey there. Take a deep breath.

If you're reading this, you've already done the hardest part -- you decided to start.

It doesn't matter if you've never written a line of code, or if you tried LeetCode once and felt completely lost. That's normal. Everyone starts somewhere. The engineers at Google, Meta, Amazon -- they all started exactly where you are right now.

This guide was built for **you**. Not for someone who already knows what a "topological sort" is. Not for someone who's been grinding problems for years. For *you*, the person who wants to learn from scratch, step by step, with no confusing jargon and no judgment.

You're going to be okay. Let's do this together.

---

## Who Is This For?

- You're a **complete beginner** to data structures and algorithms
- You want to prepare for **FAANG-level technical interviews** (Google, Meta, Amazon, Apple, Netflix, Microsoft, and similar companies)
- You learn best when things are explained **simply and patiently**
- You want a **clear roadmap** -- not a random list of 500 problems
- You've maybe tried LeetCode before and felt overwhelmed
- You want to go from "I don't know where to start" to "I can solve medium-level problems confidently"
- You just need to know basic Python syntax to get going

If any of that sounds like you, you're in the right place.

---

## How to Use This Guide

1. **Go in order.** The folders are numbered for a reason. Start with `00_getting_started` and work your way up. Each section builds on the last.

2. **Read the "Baby Explanation" first.** Every file starts with a super simple explanation. Read that before anything else. If the baby explanation makes sense, the rest will too.

3. **Understand before you memorize.** Don't rush. If something doesn't click, re-read it. Sleep on it. Come back tomorrow. That's not failure -- that's how learning works.

4. **Type every template by hand.** Don't copy-paste. Typing it yourself builds muscle memory in your brain. It really does make a difference.

5. **Use the 21-Day Study Plan below.** If you want structure, follow the day-by-day plan. It tells you exactly what to read and what to practice each day.

6. **Talk out loud.** When solving problems, explain your thinking out loud. This is how real interviews work, and practicing it early makes a huge difference.

7. **Re-read the cheat sheets** before your interviews for a quick refresher.

---

## Roadmap -- What's in Each Folder

| Step | Folder | What You'll Learn | Why It Matters |
|------|--------|-------------------|----------------|
| 0 | `00_getting_started/` | How to think about problems, common mistakes, Big O, interview workflow | This is your foundation. Everything else builds on it. |
| 1 | `01_core_patterns/` | Arrays, hashing, two pointers, sliding window, stacks, binary search | These patterns show up in 60%+ of interview questions. |
| 2 | `02_trees/` | Tree traversal (DFS, BFS), BST operations, LCA, tree DP | Trees are the #1 most tested topic at FAANG companies. |
| 3 | `03_graphs/` | Graph traversal, topological sort, union find, shortest paths (Dijkstra) | Graphs are the "boss level" -- mastering them sets you apart. |
| 4 | `04_dynamic_programming/` | 1D DP, 2D DP, knapsack, LIS, tree DP | DP is the most feared topic, but we'll make it feel approachable. |
| 5 | `05_practice_problems/` | Curated problems organized by pattern and difficulty | Targeted practice to lock in everything you've learned. |
| 6 | `cheat_sheets/` | Quick reference sheets for every pattern | Your last-minute review before the big day. |

---

## 21-Day Beginner to FAANG Study Plan

This plan assumes you can dedicate **2-4 hours per day**. If you have less time, just stretch it out -- do it in 30 days or 42 days. There is absolutely no rush. The goal is understanding, not speed.

&nbsp;

### Week 1: Build Your Foundation

| Day | Focus | What to Read | Problems to Solve | Notes |
|-----|-------|-------------|-------------------|-------|
| **Day 1** | Getting Started | `00_getting_started/01_how_to_think_in_dsa.md`, `00_getting_started/02_big_o_like_a_baby.md` | None -- just read and absorb | Today is about mindset. No pressure to solve anything yet. |
| **Day 2** | Mistakes + Workflow | `00_getting_started/03_common_mistakes_and_how_to_fix.md`, `00_getting_started/04_interview_workflow_template.md` | Practice the 7-step workflow on paper with a simple problem (try Two Sum) | Learn the *process* before the patterns. |
| **Day 3** | Arrays + Hashing | `01_core_patterns/01_arrays_and_hashing.md` | Two Sum (#1), Contains Duplicate (#217), Valid Anagram (#242) | Your first real pattern! Hash maps are your new best friend. |
| **Day 4** | Two Pointers | `01_core_patterns/02_two_pointers.md` | Valid Palindrome (#125), Two Sum II (#167), 3Sum (#15) | Think of two pointers like two fingers walking along an array. |
| **Day 5** | Sliding Window | `01_core_patterns/03_sliding_window.md` | Best Time to Buy and Sell Stock (#121), Longest Substring Without Repeating Characters (#3), Max Consecutive Ones III (#1004) | Sliding window = a moving "window" that slides across your data. |
| **Day 6** | Stacks | `01_core_patterns/04_stacks.md` | Valid Parentheses (#20), Min Stack (#155), Daily Temperatures (#739) | Stacks are like a stack of plates -- last in, first out. |
| **Day 7** | Binary Search | `01_core_patterns/05_binary_search.md` | Binary Search (#704), Search in Rotated Sorted Array (#33), Find Minimum in Rotated Sorted Array (#153) | Cut the search space in half every single time. Super powerful. |

&nbsp;

### Week 2: Trees and Graphs

| Day | Focus | What to Read | Problems to Solve | Notes |
|-----|-------|-------------|-------------------|-------|
| **Day 8** | Tree Basics + DFS | `02_trees/01_tree_traversal_dfs.md` | Maximum Depth of Binary Tree (#104), Invert Binary Tree (#226), Same Tree (#100) | Trees are just nodes pointing to other nodes. That's it. |
| **Day 9** | Tree BFS | `02_trees/02_tree_traversal_bfs.md` | Binary Tree Level Order Traversal (#102), Binary Tree Right Side View (#199) | BFS = visit level by level, like reading a book line by line. |
| **Day 10** | BST + LCA | `02_trees/03_binary_search_trees.md`, `02_trees/04_lowest_common_ancestor.md` | Validate BST (#98), Lowest Common Ancestor of BST (#235), Kth Smallest Element in BST (#230) | BSTs keep things sorted. LCA = "where do two paths meet?" |
| **Day 11** | Tree DP | `02_trees/05_tree_dp.md` | Diameter of Binary Tree (#543), Binary Tree Maximum Path Sum (#124) | Combine what you know about trees with DP thinking. Take your time here. |
| **Day 12** | Graph Basics + BFS | `03_graphs/01_graph_bfs.md` | Number of Islands (#200), Rotting Oranges (#994) | Graphs are just trees with more connections -- not as scary as they sound. |
| **Day 13** | Graph DFS | `03_graphs/02_graph_dfs.md` | Clone Graph (#133), Pacific Atlantic Water Flow (#417) | DFS on graphs = explore as deep as possible, then backtrack. |
| **Day 14** | Topological Sort | `03_graphs/03_topological_sort.md` | Course Schedule (#207), Course Schedule II (#210) | "What order should I do things in?" -- that's topo sort. |
| **Day 15** | Union Find + Dijkstra | `03_graphs/04_union_find.md`, `03_graphs/05_dijkstra.md` | Number of Connected Components (#323), Network Delay Time (#743) | Union Find = grouping things. Dijkstra = shortest weighted path. |

&nbsp;

### Week 3: Dynamic Programming + Review

| Day | Focus | What to Read | Problems to Solve | Notes |
|-----|-------|-------------|-------------------|-------|
| **Day 16** | DP Basics (1D) | `04_dynamic_programming/01_dp_basics_1d.md` | Climbing Stairs (#70), House Robber (#198), Coin Change (#322) | DP = "remember what you already calculated." That's the whole idea. |
| **Day 17** | DP 2D | `04_dynamic_programming/02_dp_2d.md` | Unique Paths (#62), Longest Common Subsequence (#1143) | Same idea as 1D, but now you have a grid instead of a line. |
| **Day 18** | Knapsack + LIS | `04_dynamic_programming/03_knapsack.md`, `04_dynamic_programming/04_lis.md` | Partition Equal Subset Sum (#416), Longest Increasing Subsequence (#300), Target Sum (#494) | Classic patterns that show up again and again in interviews. |
| **Day 19** | Tree DP + Hard DP | `04_dynamic_programming/05_tree_dp.md` | House Robber III (#337), Word Break (#139) | Combine tree thinking with DP thinking. If it's tough, that's expected. |
| **Day 20** | Full Review Day | Re-read all files in `cheat_sheets/` | Redo any 5 problems you struggled with earlier | Go back to anything that felt shaky. No new material today. |
| **Day 21** | Mock Interview Day | `00_getting_started/04_interview_workflow_template.md` | Do 2 full mock interviews (45 min each) using the 7-step workflow | Simulate the real thing. Set a timer. Talk out loud. You're ready. |

&nbsp;

---

## Pattern Recognition Map

When you see a new problem and don't know where to start, use this decision tree. Start at the top and follow the arrows.

```
START HERE: Read the problem carefully. What is it asking?

Is it about a TREE or GRAPH?
 |
 |-- Yes --> Is it asking for the SHORTEST path or MINIMUM steps?
 |            |-- Yes --> Use BFS (unweighted) or Dijkstra (weighted edges)
 |            |-- No  --> Is it asking about structure, all paths, or "does a path exist"?
 |                         |-- Yes --> Use DFS
 |                         |-- No  --> Is it about ordering or dependencies?
 |                                      |-- Yes --> Topological Sort
 |                                      |-- No  --> Is it about grouping connected things?
 |                                                   |-- Yes --> Union Find
 |                                                   |-- No  --> Try DFS as your starting point
 |
 |-- No --> Is it asking for an OPTIMAL value (maximum, minimum, count of ways)?
             |
             |-- Yes --> Can you make a greedy choice that's always best at each step?
             |            |-- Yes --> Try Greedy
             |            |-- No  --> Do your current choices depend on future choices?
             |                         |-- Yes --> Use Dynamic Programming (DP)
             |                         |-- No  --> Try Greedy first, then switch to DP if it fails
             |
             |-- No --> Is the input array SORTED (or could sorting help)?
                         |
                         |-- Yes --> Are you searching for a specific value?
                         |            |-- Yes --> Binary Search
                         |            |-- No  --> Are you comparing elements from both ends?
                         |                         |-- Yes --> Two Pointers
                         |                         |-- No  --> Consider Binary Search
                         |
                         |-- No --> Is it about SUBARRAYS or SUBSTRINGS (contiguous elements)?
                                     |
                                     |-- Yes --> Is the window size fixed?
                                     |            |-- Yes --> Fixed-size Sliding Window
                                     |            |-- No  --> Variable Sliding Window or Two Pointers
                                     |
                                     |-- No --> Is it about MATCHING, COUNTING, or FINDING DUPLICATES?
                                                 |-- Yes --> Use a Hash Map or Hash Set
                                                 |-- No  --> Is it about ORDERING or NESTING (like parentheses)?
                                                              |-- Yes --> Use a Stack
                                                              |-- No  --> Re-read the problem and try again :)
```

**Pro tip:** Don't worry about memorizing this. After solving 30-40 problems, your brain will start recognizing patterns automatically. This map is just training wheels to get you started.

---

## BFS vs DFS Rule Sheet

This is one of the most common questions beginners have: "When do I use BFS and when do I use DFS?" Here's a simple table to help you decide.

| Question to Ask Yourself | Use BFS | Use DFS |
|--------------------------|---------|---------|
| Do I need the **shortest path** in an unweighted graph? | **Yes** -- BFS guarantees it | No -- DFS doesn't guarantee shortest |
| Do I need to visit nodes **level by level**? | **Yes** -- BFS is built for this | No |
| Do I need to explore **all paths** or **all possibilities**? | No | **Yes** -- DFS is natural for this |
| Am I working with a **very deep** tree/graph? | **Safer** -- BFS won't stack overflow | Risky -- DFS could overflow the call stack |
| Am I working with a **very wide** tree/graph? | Risky -- BFS queue can use lots of memory | **Safer** -- DFS uses less memory |
| Do I need to find **connected components**? | Either works | Either works |
| Am I doing **topological sort**? | Works (Kahn's algorithm) | Works (DFS-based) |
| Is the problem about **tree height or depth**? | Works | Works (and usually simpler) |
| Is the problem about **root-to-leaf paths**? | Awkward to implement | **Natural fit** |
| Do I need to **backtrack** (undo choices)? | No -- BFS doesn't backtrack | **Yes** -- DFS backtracks naturally |

&nbsp;

### Quick Memory Trick

- **BFS** = **B**readth = **B**road = explores **widely** first, like ripples spreading in a pond
- **DFS** = **D**epth = **D**eep = explores **deeply** first, like going down a rabbit hole

### When in Doubt

- If the problem says "shortest," "minimum steps," or "nearest" --> **BFS**
- If the problem says "all paths," "exists a path," or "backtrack" --> **DFS**
- If neither is obvious --> **Try DFS first** (it's usually simpler to code with recursion)

---

## Tree Recursion Checklist

Before you write any recursive tree solution, run through this checklist. It will save you from 90% of tree-related bugs.

- [ ] **What is my base case?** Usually: `if node is None: return something`. Ask yourself: what should I return for an empty tree? (Often it's `0`, `True`, `None`, or an empty list.)

- [ ] **What do I need from my left subtree?** Call your function recursively on `node.left`. What value does it give you back? Be specific -- is it a number? A boolean? A list?

- [ ] **What do I need from my right subtree?** Same question for `node.right`. Usually it's the same type of value as the left.

- [ ] **How do I combine left, right, and the current node?** This is the heart of your solution. How do the pieces fit together at this node?

- [ ] **Am I updating a global variable or returning a value?** Pick one approach and be consistent. Mixing them up is the #1 source of tree bugs. (Returning values is usually cleaner.)

- [ ] **Does my solution handle edge cases?** Test mentally with: an empty tree (`None`), a tree with just one node, and a lopsided tree (all nodes going left or right).

&nbsp;

### The Tree Recursion Template

```python
def solve(node):
    # Step 1: Base case -- what if the node is empty?
    if node is None:
        return base_value

    # Step 2: Get answers from children
    left_answer = solve(node.left)
    right_answer = solve(node.right)

    # Step 3: Combine and return
    return combine(left_answer, right_answer, node.val)
```

This template works for the vast majority of tree problems. Master it and you'll feel at home with trees.

---

## DP State Definition Checklist

Dynamic Programming scares everyone at first. But here's a secret: it's really just answering a few specific questions. Use this checklist every single time you face a DP problem.

- [ ] **What am I trying to find?** Write it in one plain English sentence. Example: "The minimum number of coins needed to make amount X."

- [ ] **What are my choices at each step?** List every option. Example: "I can use a penny (1), a nickel (5), or a dime (10)."

- [ ] **What changes after I make a choice?** This is your "state" -- the thing that's different after each decision. Example: "The remaining amount I still need to make."

- [ ] **Can I define `dp[i]` in one plain English sentence?** Write it out: "`dp[i]` = the minimum number of coins to make amount `i`." If you can't write this sentence clearly, stop and think more before coding.

- [ ] **What is my base case?** What's the simplest version of the problem where you already know the answer? Example: "`dp[0] = 0` because it takes 0 coins to make amount 0."

- [ ] **What is my recurrence relation?** How does `dp[i]` relate to smaller subproblems? Example: "`dp[i] = min(dp[i - coin] + 1)` for each coin I could use."

&nbsp;

### The DP Template

```python
def solve(input_data):
    # Step 1: Define your dp array with default values
    dp = [default_value] * (target + 1)

    # Step 2: Fill in base cases (the answers you already know)
    dp[0] = known_answer

    # Step 3: Fill the rest using your recurrence relation
    for i in range(1, target + 1):
        for choice in all_choices:
            if choice is valid:
                dp[i] = best_of(dp[i], dp[smaller_subproblem] + cost)

    # Step 4: Return the final answer
    return dp[target]
```

Once you see this pattern, you'll realize most DP problems are just variations of the same idea.

---

## Coding Interview Workflow Template

Follow these 7 steps in **every single interview**. Even if you know the answer immediately, walk through each step. It shows the interviewer that you're organized, thoughtful, and a great communicator.

| Step | What to Do | Time | What to Say Out Loud |
|------|-----------|------|----------------------|
| **1. Clarify** | Ask questions about input, output, constraints, and edge cases | 3-5 min | "Before I dive in, let me make sure I understand the problem..." |
| **2. Examples** | Walk through 1-2 examples by hand on paper or whiteboard | 2-3 min | "Let me trace through this example to make sure I get it..." |
| **3. Identify Pattern** | Figure out which algorithm pattern fits this problem | 2-3 min | "This reminds me of a [pattern] problem because..." |
| **4. Plan** | Explain your approach step by step before writing any code | 3-5 min | "Here's my plan: First I'll... then I'll... finally I'll..." |
| **5. Code** | Write clean, readable code while narrating what you're doing | 15-20 min | "I'm creating a hash map here to store... now I'm looping through..." |
| **6. Test** | Trace through your code with an example, line by line | 3-5 min | "Let me walk through my code with this test case..." |
| **7. Complexity** | State time and space complexity with brief justification | 1-2 min | "The time complexity is O(n) because we loop once... space is O(n) for the hash map." |

&nbsp;

**The Golden Rule:** Always be talking. Silence makes interviewers nervous. Even if you're thinking, say something like:

> "I'm thinking about whether a hash map or sorting approach would be better here... Let me consider the trade-offs."

For a detailed walkthrough with example dialogue, see [00_getting_started/04_interview_workflow_template.md](00_getting_started/04_interview_workflow_template.md).

---

## 50 Curated FAANG-Level Problems

These are the 50 problems that give you the most "bang for your buck." Solve these, and you'll have seen the core idea behind hundreds of other interview questions.

Solve them in order. The easy ones build your confidence. The mediums build your skill. The hards show you're ready.

&nbsp;

### Arrays and Hashing (5)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 1 | Two Sum | Easy | Hash Map lookup | #1 |
| 2 | Contains Duplicate | Easy | Hash Set for uniqueness | #217 |
| 3 | Valid Anagram | Easy | Character frequency counting | #242 |
| 4 | Group Anagrams | Medium | Hash Map + sorted key | #49 |
| 5 | Top K Frequent Elements | Medium | Hash Map + heap/bucket sort | #347 |

&nbsp;

### Two Pointers (4)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 6 | Valid Palindrome | Easy | Two pointers moving inward | #125 |
| 7 | Two Sum II (Input Array Is Sorted) | Medium | Two pointers moving inward | #167 |
| 8 | 3Sum | Medium | Sort + two pointers | #15 |
| 9 | Container With Most Water | Medium | Two pointers moving inward | #11 |

&nbsp;

### Sliding Window (3)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 10 | Best Time to Buy and Sell Stock | Easy | Track running minimum | #121 |
| 11 | Longest Substring Without Repeating Characters | Medium | Variable sliding window + set | #3 |
| 12 | Minimum Window Substring | Hard | Variable sliding window + hash map | #76 |

&nbsp;

### Stack (3)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 13 | Valid Parentheses | Easy | Matching brackets with stack | #20 |
| 14 | Min Stack | Medium | Auxiliary stack tracking minimums | #155 |
| 15 | Daily Temperatures | Medium | Monotonic decreasing stack | #739 |

&nbsp;

### Binary Search (4)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 16 | Binary Search | Easy | Classic binary search | #704 |
| 17 | Search in Rotated Sorted Array | Medium | Modified binary search | #33 |
| 18 | Find Minimum in Rotated Sorted Array | Medium | Modified binary search | #153 |
| 19 | Koko Eating Bananas | Medium | Binary search on the answer | #875 |

&nbsp;

### Trees (8)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 20 | Maximum Depth of Binary Tree | Easy | DFS recursion | #104 |
| 21 | Invert Binary Tree | Easy | DFS recursion (swap children) | #226 |
| 22 | Same Tree | Easy | DFS comparison of two trees | #100 |
| 23 | Binary Tree Level Order Traversal | Medium | BFS with queue | #102 |
| 24 | Validate Binary Search Tree | Medium | DFS with valid range tracking | #98 |
| 25 | Lowest Common Ancestor of a BST | Medium | Use BST property to navigate | #235 |
| 26 | Kth Smallest Element in a BST | Medium | Inorder traversal | #230 |
| 27 | Binary Tree Maximum Path Sum | Hard | DFS + tree DP | #124 |

&nbsp;

### Graphs (8)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 28 | Number of Islands | Medium | BFS/DFS flood fill | #200 |
| 29 | Clone Graph | Medium | BFS/DFS + hash map for visited | #133 |
| 30 | Rotting Oranges | Medium | Multi-source BFS | #994 |
| 31 | Pacific Atlantic Water Flow | Medium | DFS from ocean borders inward | #417 |
| 32 | Course Schedule | Medium | Topological sort (cycle detection) | #207 |
| 33 | Course Schedule II | Medium | Topological sort (return ordering) | #210 |
| 34 | Number of Connected Components in Undirected Graph | Medium | Union Find or DFS | #323 |
| 35 | Network Delay Time | Medium | Dijkstra's shortest path | #743 |

&nbsp;

### Dynamic Programming (8)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 36 | Climbing Stairs | Easy | 1D DP (Fibonacci-like) | #70 |
| 37 | House Robber | Medium | 1D DP (take or skip) | #198 |
| 38 | Coin Change | Medium | 1D DP (unbounded knapsack) | #322 |
| 39 | Unique Paths | Medium | 2D DP (grid paths) | #62 |
| 40 | Longest Common Subsequence | Medium | 2D DP (two strings) | #1143 |
| 41 | Longest Increasing Subsequence | Medium | 1D DP (LIS pattern) | #300 |
| 42 | Partition Equal Subset Sum | Medium | 0/1 Knapsack | #416 |
| 43 | House Robber III | Medium | Tree DP | #337 |

&nbsp;

### Linked List (3)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 44 | Reverse Linked List | Easy | Pointer manipulation | #206 |
| 45 | Merge Two Sorted Lists | Easy | Two-pointer merge | #21 |
| 46 | Linked List Cycle | Easy | Fast and slow pointers (Floyd's) | #141 |

&nbsp;

### Other Important Problems (4)

| # | Problem Name | Difficulty | Pattern | LeetCode # |
|---|-------------|------------|---------|------------|
| 47 | Merge Intervals | Medium | Sort + merge overlapping | #56 |
| 48 | Meeting Rooms II | Medium | Sort + min heap | #253 |
| 49 | Implement Trie (Prefix Tree) | Medium | Trie data structure | #208 |
| 50 | LRU Cache | Medium | Hash Map + Doubly Linked List | #146 |

---

## Folder Structure

```
dsa-baby-to-faang/
|
|-- README.md                              <-- You are here!
|
|-- 00_getting_started/
|   |-- 01_how_to_think_in_dsa.md          How to approach any problem
|   |-- 02_big_o_like_a_baby.md            Big O notation made simple
|   |-- 03_common_mistakes_and_how_to_fix.md   The 15 mistakes every beginner makes
|   |-- 04_interview_workflow_template.md   Your 7-step interview game plan
|
|-- 01_core_patterns/
|   |-- 01_arrays_and_hashing.md           Hash maps, sets, frequency counting
|   |-- 02_two_pointers.md                 Two pointers moving inward/outward
|   |-- 03_sliding_window.md               Fixed and variable window techniques
|   |-- 04_stacks.md                       LIFO, monotonic stacks, matching
|   |-- 05_binary_search.md                Classic, rotated, and "search on answer"
|
|-- 02_trees/
|   |-- 01_tree_traversal_dfs.md           Preorder, inorder, postorder
|   |-- 02_tree_traversal_bfs.md           Level-order traversal
|   |-- 03_binary_search_trees.md          BST properties and operations
|   |-- 04_lowest_common_ancestor.md       Finding where paths meet
|   |-- 05_tree_dp.md                      DP on tree structures
|
|-- 03_graphs/
|   |-- 01_graph_bfs.md                    Breadth-first search on graphs
|   |-- 02_graph_dfs.md                    Depth-first search on graphs
|   |-- 03_topological_sort.md             Ordering with dependencies
|   |-- 04_union_find.md                   Grouping connected components
|   |-- 05_dijkstra.md                     Shortest path with weights
|
|-- 04_dynamic_programming/
|   |-- 01_dp_basics_1d.md                 1D DP: stairs, robber, coins
|   |-- 02_dp_2d.md                        2D DP: grids and two strings
|   |-- 03_knapsack.md                     0/1 and unbounded knapsack
|   |-- 04_lis.md                          Longest Increasing Subsequence
|   |-- 05_tree_dp.md                      DP on trees
|
|-- 05_practice_problems/
|   |-- (organized by pattern and difficulty)
|
|-- cheat_sheets/
    |-- (quick reference for each pattern)
```

---

## A Few Last Words

Learning DSA is a marathon, not a sprint. There will be days when you feel stuck, days when a single problem takes 3 hours and you still don't get it. That's not a sign that you're bad at this. That's a sign that you're learning something genuinely hard.

Here's something nobody tells beginners: **everyone struggles with this.** The people who succeed aren't the ones who find it easy -- they're the ones who keep going when it's hard.

Every expert was once a beginner who refused to give up.

You've got this. Seriously. Now go open `00_getting_started/01_how_to_think_in_dsa.md` and let's begin.

---

*Built with care for beginners. If this helped you, consider sharing it with someone else who's starting their journey.*
